"use strict";
const command_1 = require("@oclif/command");
const path = require("path");
const fs = require("fs");
const Mustache = require("mustache");
class GenerateGlobalDTs extends command_1.Command {
    async run() {
        var _a;
        const { args } = this.parse(GenerateGlobalDTs);
        const envPath = (_a = args.file) !== null && _a !== void 0 ? _a : '.env';
        this.log(`getting variables from ${envPath}`);
        const envVariables = this.getEnvVariables(envPath);
        const filePath = path.join(process.cwd(), 'global.d.ts');
        if (!fs.existsSync(filePath)) {
            fs.writeFileSync(filePath, ``);
        }
        const file = this.renderFile(envVariables);
        fs.writeFileSync(path.resolve(process.cwd(), 'global.d.ts'), file);
        this.log('successfully generated');
    }
    getEnvVariables(envPath) {
        const envVariables = [];
        fs.readFileSync(path.join(process.cwd(), envPath), 'utf-8')
            .split(/\r?\n/)
            .forEach((line) => {
            if (line)
                envVariables.push(line.split('=')[0]);
        });
        return envVariables;
    }
    renderFile(envVariables) {
        return Mustache.render(this.template(), {
            variables: envVariables
                .filter((e) => e !== 'NODE_ENV' && e !== 'PORT')
                .map((e) => ({ variableName: e })),
        });
    }
    template() {
        return `declare namespace NodeJS {
      interface ProcessEnv {
        NODE_ENV: 'development' | 'test' | 'staging' | 'production';
        PORT: string;
        {{#variables}}
        {{variableName}}: string;
        {{/variables}}
      }
    }
    `;
    }
}
GenerateGlobalDTs.description = 'describe the command here';
GenerateGlobalDTs.flags = {
    version: command_1.flags.version({ char: 'v' }),
    help: command_1.flags.help({ char: 'h' }),
};
GenerateGlobalDTs.args = [{ name: 'file', description: 'path to env file. defaults to .env' }];
module.exports = GenerateGlobalDTs;
